#!/usr/bin/env python3


class PcdLoader:
    """Loader of a PCD file, with writing function to ascii format."""

    def __init__(self, filename: str) -> None:
        """Constructor to initialize the loader with one pcd file.

        Args:
            filename: path of input pcd file
        """
        assert filename.endswith(".pcd")
        self.load(filename=filename)

    def __str__(self):
        """Print this point cloud."""
        if not bool(self.data):
            return "Empty object, load one pcd first"

        result = f"One point cloud with fields {list(self.data.keys())}\n"
        for k, v in self.data.items():
            result += f"field: {k}\n{v}\n"

        return result

    def _reset(self):
        """Reset the class members."""
        self.headers = {}
        self.data = {}

    def _build_ascii_header(self) -> str:
        """Construct the header of ascii file of this object.

        Returns:
            string until DATA field (inclusive)
        """
        return "\n".join(
            "{} {}".format(key, " ".join(val) if key != "DATA" else "ascii")
            for key, val in self.headers.items()
        )

    def _parse_ascii(self, content: bytearray) -> None:
        """Parse content in ascii format.

        Args:
            content: part of input file in bytestring format
        """
        lines = [
            line.strip()
            for line in content.decode("utf-8").split("\n")
            if bool(line.strip())
        ]
        self.data = {f: [] for f in self.headers["FIELDS"]}
        for line in lines:
            for v, t, f in zip(
                line.split(" "), self.headers["TYPE"], self.headers["FIELDS"]
            ):
                v = float(v) if t == "F" else int(v)
                self.data[f].append(v)

    @staticmethod
    def _conv_format(t: str, s: str) -> str:
        """Get the format in python struct for the give type and size.

        Args:
            t: type name
            s: size name

        Returns:
            the name in python struct; if it is not supported, an exception will be thrown
        """
        if t == "F":
            if s == "4":
                return "f"
            elif s == "8":
                return "d"
        elif t in ("I", "U"):
            if s == "1":
                return "c"
            elif s == "4":
                return "i"
            elif s == "8":
                return "q"

        assert 1 == 0, f"unsupported type {t} and size {s}"

    def _parse_binary(self, content: bytearray) -> None:
        """Parse content in binary format.

        Args:
            content: part of input file in bytestring format
        """
        import struct

        self.data = {f: [] for f in self.headers["FIELDS"]}

        line_format = "".join(
            self._conv_format(t, s)
            for t, s in zip(self.headers["TYPE"], self.headers["SIZE"])
        )
        num_points = int(self.headers["POINTS"][0])
        content_format = line_format * num_points
        unpacked_struct = struct.unpack(content_format, content)

        ip = 0
        for i in range(num_points):
            for t, f in zip(self.headers["TYPE"], self.headers["FIELDS"]):
                self.data[f].append(unpacked_struct[ip])
                ip += 1

    @staticmethod
    def _lzf_decompress(input_bytes: bytearray, output_size: int) -> bytearray:
        """Decompress one lzf bytestring.

        Args:
            input_bytes: input compressed buffer
            output_size: expected size of uncompressed data
        """
        # this code generated by github copilot at 2025-01-15, and then
        # adapted with bug fix
        i = o = 0
        input_length = len(input_bytes)
        output_bytes = bytearray(output_size)

        while i < input_length:
            ctrl = input_bytes[i]
            i += 1

            if ctrl < 32:
                # Literal run
                ctrl += 1
                output_bytes[o : o + ctrl] = input_bytes[i : i + ctrl]
                o += ctrl
                i += ctrl
            else:
                # Back reference
                length = ctrl >> 5
                if length == 7:
                    length += input_bytes[i]
                    i += 1

                reference = o - ((ctrl & 0x1F) << 8) - input_bytes[i] - 1
                i += 1

                length += 2
                # the AI generated code applies block copy, but because of
                # time-dependency between the memory blocks starting with o
                # and reference, it will write with invalid data
                for idx in range(length):
                    output_bytes[o] = output_bytes[reference]
                    o += 1
                    reference += 1

        return output_bytes

    def _parse_binary_compressed(self, content: bytearray) -> None:
        """Parse content in binary_compressed format.

        Args:
            content: part of input file in bytestring format
        """
        import struct

        size1 = int.from_bytes(content[:4], byteorder="little")
        size2 = int.from_bytes(content[4:8], byteorder="little")
        size_unc, size_com = (
            max(size1, size2),
            min(size1, size2),
        )  # I may have seen one not following pcd format desc

        content = content[8:]
        assert size_com == len(content)

        formats = [
            self._conv_format(t, s)
            for t, s in zip(self.headers["TYPE"], self.headers["SIZE"])
        ]
        num_points = int(self.headers["POINTS"][0])
        formatting = "".join(f * num_points for f in formats)
        unpacked_struct = struct.unpack(
            formatting, self._lzf_decompress(content, size_unc)
        )

        self.data = {
            f: unpacked_struct[(i * num_points) : ((i + 1) * num_points)]
            for i, f in enumerate(self.headers["FIELDS"])
        }

    def save_ascii(self, filename: str) -> None:
        """Save the object in ascii format.

        Args:
            filename: path of output pcd file
        """

        assert len(set(len(val) for val in self.data.values())) <= 1

        num_points = len(list(self.data.values())[0]) if bool(self.data) else 0
        with open(filename, "w", encoding="utf-8") as fo:
            fo.write(self._build_ascii_header() + "\n")

            lines = [
                " ".join(str(self.data[f][i]) for f in self.headers["FIELDS"])
                for i in range(num_points)
            ]
            fo.write("\n".join(lines) + "\n")

    def load(self, filename: str) -> None:
        """Load one pcd file.

        Args:
            filename: path of input pcd file
        """
        self._reset()

        with open(filename, "rb") as fi:
            content = fi.read()

        lines = content.split(b"\n")

        is_header = True
        data_lines = []

        for line in lines:
            if is_header:
                if line.startswith(b"DATA "):
                    is_header = False

                elements = line.decode("utf-8").split(" ")
                self.headers[elements[0]] = elements[1:]
            else:
                data_lines.append(line)

        content = b"\n".join(data_lines)
        self.headers["TYPE"] = [t.upper() for t in self.headers["TYPE"]]
        assert all(t in ("I", "U", "F") for t in self.headers["TYPE"])
        assert all(c == "1" for c in self.headers["COUNT"])

        parser = {
            "ascii": self._parse_ascii,
            "binary": self._parse_binary,
            "binary_compressed": self._parse_binary_compressed,
        }
        parser[self.headers["DATA"][0]](content)
